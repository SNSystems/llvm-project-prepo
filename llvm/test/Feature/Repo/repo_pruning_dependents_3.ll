; This test checks there is no redundant dependent 'str' with the private linkage
; type in a compilation file.
; The explanation of the dependents is given in the repo_pruning_dependents.ll,
; Please refer to the file for details.
;
; The test compiled two IR files: repo_pruning_dependent_with_private_linkage.ll and
; repo_prunning_dependents_3.ll and then dump all the compilations from the database.
; There are two compilations in the database, and each compilation should only contains
; a 'str' compilation member. Therefore, the 'name:str' should appear just twice.
;
; The steps in this test are:
; Step 1: Remove the database.
; Step 2: Start from repo_pruning_dependent_with_private_linkage.ll which is an ELF IR.
;         Insert the RepoDefinition to generate IR targeting the Repo.
; Step 3: Remove the variable str's RepoDefinition metadata from the %t.repo.ll.
; Step 4: Since the variable 'str' doesn't have the RepoDefinition, the digest of variable 'str' is
;         generated by the RepoObjectWriter and added into the dependent of the function 'g'.
; Step 5: Start from repo_prunning_dependents_3.ll which is an ELF IR. Insert the RepoDefinition to
;         generate IR targeting the Repo. In this step, the IR code firstly pass the
;         RepoMetadataGenerator pass to generate the digests of function 'a' and variables 'str'
;         and 'src'. During the RepoPruning pass, the function 'a' is pruned and its dependent
;         'str' is added to the 'repo.tickets'.
; Step 6: Check that 1) the function 'a' and it dependent 'str' are pruned. 2) the 'str' is renamed.
; Step 7: Remove the variable str's RepoDefinition metadata from the %t.repo.2.ll.
; Step 8: Generate the Repo object file again. The repo.tockets in the %t.2.ll file contains the
;         variable 'a' and its dependent 'str.{{.*}}'. In this step, the digest of variable 'str'
;         is also generated by the RepoObjectWriter but not be added into the 'repo.tickets' since
;         a 'str' RepoDefinition has been added during the pruning pass.
; Step 9: Dump the compilation members and check the 'name:str'.
;
; RUN: rm -f %t.db
; RUN: env REPOFILE=%t.db opt -O0 -mtriple=x86_64-pc-linux-gnu-repo -S %S/Inputs/repo_pruning_dependent_with_private_linkage.ll -o %t.repo.ll
; RUN: %python %S/Inputs/remove_GO_repodefinition.py -r str -i %t.repo.ll -o %t.1.ll
; RUN: env REPOFILE=%t.db llc -mtriple="x86_64-pc-linux-gnu-repo" -filetype=obj %t.1.ll -o %t.1.o
; RUN: env REPOFILE=%t.db opt -O0 -mtriple=x86_64-pc-linux-gnu-repo -S %s -o %t.repo.2.ll
; RUN: FileCheck %s < %t.repo.2.ll --check-prefix=CHECK-PRUNING
; RUN: %python %S/Inputs/remove_GO_repodefinition.py -r str -i %t.repo.2.ll -o %t.2.ll
; RUN: env REPOFILE=%t.db llc -mtriple="x86_64-pc-linux-gnu-repo" -filetype=obj %t.2.ll -o %t.2.o
; RUN: env REPOFILE=%t.db pstore-dump --all-compilations %t.db | FileCheck %s

target triple = "x86_64-pc-linux-gnu-elf"

@str = private constant [6 x i8] c"Ipsum\00", align 1

define void @a() {
entry:
  %puts = tail call i32 @puts(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str, i64 0, i64 0))
  ret void
}
declare i32 @puts(i8* nocapture readonly)

; CHECK-PRUNING: !RepoDefinition(name: "a", digest: [16 x i8] c"{{.*}}", linkage: external, visibility: default, pruned: true)
; CHECK-PRUNING: !RepoDefinition(name: "str.{{.*}}", digest: [16 x i8] c"{{.*}}", linkage: private, visibility: default, pruned: true)
; CHECK:     name    : str
; CHECK:     name    : str
; CHECK-NOT: name    : str
