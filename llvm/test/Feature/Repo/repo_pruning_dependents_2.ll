; This test checks there is no redundant dependent GOs in a compilation file.
; The explanation of the dependents is given in the repo_pruning_dependents.ll,
; Please refer to the file for details.
;
; If the digest of function B is generated by the RepoObjectWriter and a B RepoDefinition is
; also added during the pruning pass, the function B will use the existing RepoDefinition.
;
; The steps in this test are:
; Step 1: Remove the database.
; Step 2: Start from an ELF IR, insert the RepoDefinition to generate IR targeting the Repo.
; Step 3: Remove the function B's RepoDefinition metadata from the %t.repo.ll.
; Step 4: Since the function B doesn't have the RepoDefinition, the digest of function B is generated
;         by the RepoObjectWriter and added into the dependent of the function A.
; Step 5: Dump all compilation members in the database. There are 2 compilation members, which are
;         functions A and B.
; Step 6: Generate the Repo IR code from the same source IR code again. In this step, the IR code
;         firstly pass the RepoMetadataGenerator pass to generate the digests of functions A and
;         B. During the RepoPruning pass, the function A is pruned and its dependent B is added
;         to the 'repo.tickets'.
; Step 7: Check that the function A and it dependent B are pruned.
; Step 8: Remove the function B's RepoDefinition metadata from the %t.repo.2.ll.
; Step 9: Generate the Repo object file again. The repo.tockets in the %t.2.ll file contains the
;         function A and its dependent B. In this step, the digest of function B is also
;         generated by the RepoObjectWriter but not be added into the 'repo.tickets' since a B
;         RepoDefinition has been added during the pruning pass.
; Step 10: Dump all compilation members in the database again. The compilations, which are generated
;          by step 4 and step 9, should be the same. Therefore, there are only one compilation, which
;          includes two members: functions A and B.
; Step 11: Check that the step 5 and step 10 generate the same compilation members.
;
; RUN: rm -f %t.db
; RUN: env REPOFILE=%t.db clang -O0 -S -emit-llvm --target=x86_64-pc-linux-gnu-repo -x ir %s  -o %t.repo.ll
; RUN: %python %S/Inputs/remove_GO_repodefinition.py -r B -i %t.repo.ll -o %t.ll
; RUN: env REPOFILE=%t.db llc -mtriple="x86_64-pc-linux-gnu-repo" -filetype=obj %t.ll -o %t.1.o
; RUN: env REPOFILE=%t.db pstore-dump  --all-compilations %t.db > %t.1.log
; RUN: env REPOFILE=%t.db clang -O0 -S -emit-llvm --target=x86_64-pc-linux-gnu-repo -x ir %s  -o %t.repo.2.ll
; RUN: FileCheck %s < %t.repo.2.ll
; RUN: %python %S/Inputs/remove_GO_repodefinition.py -r B -i %t.repo.2.ll -o %t.2.ll
; RUN: env REPOFILE=%t.db llc -mtriple="x86_64-pc-linux-gnu-repo" -filetype=obj %t.2.ll -o %t.2.o
; RUN: env REPOFILE=%t.db pstore-dump  --all-compilations %t.db > %t.2.log
; RUN: diff %t.1.log %t.2.log

target triple = "x86_64-pc-linux-gnu-elf"

define i32 @A() {
entry:
  %call = call i32 @B()
  ret i32 %call
}

define i32 @B() {
entry:
  ret i32 1
}

; CHECK: !RepoDefinition(name: "A", digest: [16 x i8] c"{{.*}}", linkage: external, visibility: default, pruned: true)
; CHECK: !RepoDefinition(name: "B", digest: [16 x i8] c"{{.*}}", linkage: external, visibility: default, pruned: true)
