; This test checks the program repository pruning pass for the dependents.
;
; In the llvm-project-prepo project, the GO's digest could be generated either by the
; RepoMetadataGenerator pass or by the RepoObjectWriter. When a new global object (GO)
; is generated by an LLVM optimisation pass after the RepoMetadataGenerator pass, the
; digest will be generated by the RepoObjectWriter. If a fragment has an external fixup
; referencing this GO, we add the GO's compilation member address to the dependents.
;
; When a fragment is pruned, all its dependents need to be recorded in the repo.tickets
; metadata to guarantee that the dependents (those GO generated by later optimizations)
; are present in the final compilation record.
;
; In the test, the digest of A is given in the RepoDefinition (as if it were generated
; by the RepoMetadataGenerator pass). The digests of B and C will be generated by the
; RepoObjectWriter. Since Function A is dependent on function B and B is dependent
; on function C, both RepoDefinitions of B and C need to be added into the 'repo.tickets'
; during the pruning.
;
; The steps in this test are:
; Step 1: Remove the database.
; Step 2: Start from an ELF IR, insert the RepoDefinition to generate IR targeting the Repo.
; Step 3: Remove the RepoDefinition metadata from the functions B and C.
; Step 4: Since the functions B and C don't have the RepoDefinition, the digest of functions B
;         and C are generated by the RepoObjectWriter and added these two functions into
;         the dependents of the function A.
; Step 5: Dump all compilation members in the database. There are 3 compilation members,
;         which are functions A, B and C.
; Step 6: Re-build the same source IR code again. In this step, the IR code firstly pass the
;         RepoMetadataGenerator pass to generate the digests of functions A, B and C.
;         During the RepoPruning pass, the function A is pruned and its dependents B and
;         C are added.
; Step 7: Dump all compilation members in the database again. The compilations, which are
;         generated by step 4 and step 6, should be the same. Therefore, there are only one
;         compilation, which includes three members: functions A, B and C.
; Step 8: Check that the step 5 and step 7 generate the same compilation members.
;
; RUN: rm -f %t.db
; RUN: env REPOFILE=%t.db clang -O0 -S -emit-llvm --target=x86_64-pc-linux-gnu-repo -x ir %s  -o %t.repo.ll
; RUN: %python %S/Inputs/remove_GO_repodefinition.py -r B C -i %t.repo.ll -o %t.ll
; RUN: env REPOFILE=%t.db llc -mtriple="x86_64-pc-linux-gnu-repo" -filetype=obj %t.ll -o %t.1.o
; RUN: env REPOFILE=%t.db pstore-dump  --all-compilations %t.db > %t.1.log
; RUN: env REPOFILE=%t.db clang -O0 -c --target=x86_64-pc-linux-gnu-repo -x ir %s -o %t.2.o
; RUN: env REPOFILE=%t.db pstore-dump  --all-compilations %t.db > %t.2.log
; RUN: diff %t.1.log %t.2.log

target triple = "x86_64-pc-linux-gnu-elf"

define i32 @A() {
entry:
  %call = call i32 @B()
  ret i32 %call
}

define internal i32 @B() {
entry:
  %call = call i32 @C()
  ret i32 %call
}

define internal i32 @C() {
entry:
  ret i32 1
}
